#pragma once
#include "extend/action-model.hpp"
#include "omni-icon.hpp"
#include "theme.hpp"
#include "ui/keyboard-shortcut-indicator.hpp"
#include "ui/keyboard.hpp"
#include "ui/omni-list-item-widget.hpp"
#include "ui/omni-list.hpp"
#include "ui/selectable-omni-list-widget.hpp"
#include <qboxlayout.h>
#include <qcoreevent.h>
#include <qevent.h>
#include <qhash.h>
#include <qkeysequence.h>
#include <qlabel.h>
#include <qlineedit.h>
#include <qlist.h>
#include <qlistwidget.h>
#include <qnamespace.h>
#include <qobject.h>
#include <qpixmap.h>
#include <qstack.h>
#include <qstackedlayout.h>
#include <qtmetamacros.h>
#include <qvariant.h>
#include <qwidget.h>
#include <variant>
#include <QStackedLayout>

class AppWindow;

class AbstractPannelActionnable : public QObject {
  Q_OBJECT

public:
  QString title;
  OmniIconUrl iconUrl;
  std::optional<KeyboardShortcutModel> shortcut;
  std::function<void(void)> _execCallback;

  void setShortcut(const KeyboardShortcutModel &shortcut) { this->shortcut = shortcut; }
  void setExecutionCallback(const std::function<void(void)> &cb) { _execCallback = cb; }

  std::function<void(void)> executionCallback() const { return _execCallback; }

  AbstractPannelActionnable(const QString &title, const OmniIconUrl &icon) : title(title), iconUrl(icon) {}
  virtual void execute(AppWindow &app) = 0;

signals:
  void didExecute();
};

class AbstractAction : public AbstractPannelActionnable {
public:
  AbstractAction(const QString &title, const OmniIconUrl &icon) : AbstractPannelActionnable(title, icon) {}
};

class ActionLabel {
  QString _label;

public:
  const QString &label() const { return _label; }

  ActionLabel(const QString &label) : _label(label) {}
};

class ActionSection;
using ActionItem = std::variant<ActionLabel, AbstractAction *, ActionSection *>;

class ActionSection : public AbstractPannelActionnable {
public:
  virtual std::vector<ActionItem> generateItems(const QString &query) const = 0;

  void execute(AppWindow &app) override;

  ActionSection(const QString &title, const OmniIconUrl &icon) : AbstractPannelActionnable(title, icon) {}
};

class FixedActionSection : public ActionSection {
  std::vector<ActionItem> _items;

  std::vector<ActionItem> generateItems(const QString &query) const override { return _items; }

public:
  FixedActionSection(const QString &title, const OmniIconUrl &icon, const std::vector<ActionItem> &items)
      : ActionSection(title, icon), _items(items) {}
};

class ActionListWidget : public SelectableOmniListWidget {
  OmniIcon *_icon;
  QLabel *_label;
  KeyboardShortcutIndicatorWidget *_shortcut;

public:
  ActionListWidget &setIconUrl(const OmniIconUrl &url) {
    _icon->setUrl(url);
    return *this;
  }

  ActionListWidget &setShortcut(const KeyboardShortcutModel &shortcut) {
    _shortcut->setShortcut(shortcut);
    _shortcut->show();
    return *this;
  }

  ActionListWidget &clearShortcut() {
    _shortcut->hide();
    return *this;
  }

  ActionListWidget &setTitle(const QString &title) {
    _label->setText(title);
    return *this;
  }

  void selectionChanged(bool selected) override {
    SelectableOmniListWidget::selectionChanged(selected);
    auto &theme = ThemeService::instance().theme();

    if (selected) {
      _shortcut->setBackgroundColor(theme.colors.statusBackground);
    } else {
      _shortcut->setBackgroundColor(theme.colors.statusBackground);
    }
  }

  ActionListWidget()
      : _icon(new OmniIcon), _label(new QLabel), _shortcut(new KeyboardShortcutIndicatorWidget) {
    auto &theme = ThemeService::instance().theme();
    auto layout = new QHBoxLayout;

    _shortcut->hide();
    _shortcut->setBackgroundColor(theme.colors.statusBackground);

    _icon->setFixedSize(22, 22);
    layout->setAlignment(Qt::AlignVCenter);
    layout->setSpacing(10);
    layout->addWidget(_icon);
    layout->addWidget(_label);
    layout->addWidget(_shortcut, 0, Qt::AlignRight);
    layout->setContentsMargins(8, 8, 8, 8);

    setLayout(layout);
  }
};

class ActionListItem : public OmniList::AbstractVirtualItem {
public:
  AbstractPannelActionnable *action;

  QString id() const override { return action->title + action->iconUrl.toString(); }

  OmniListItemWidget *createWidget() const override {
    auto widget = new ActionListWidget;

    setup(widget);

    return widget;
  }

  int calculateHeight(int width) const override {
    static ActionListWidget ruler;

    return ruler.sizeHint().height();
  }

  bool recyclable() const override { return true; }

  void setup(ActionListWidget *widget) const {
    widget->setTitle(action->title).setIconUrl(action->iconUrl);

    if (auto shortcut = action->shortcut) {
      widget->setShortcut(*shortcut);
    } else {
      widget->clearShortcut();
    }
  }

  void recycle(QWidget *base) const override { setup(static_cast<ActionListWidget *>(base)); }

public:
  ActionListItem(AbstractPannelActionnable *action) : action(action) {}
};

class ActionView : public QWidget {
  Q_OBJECT

public:
  virtual void onSearchChanged(const QString &s) {};
  virtual bool handleKey(QKeyEvent *keyEvent) { return false; }
  virtual std::vector<AbstractPannelActionnable *> actions() const = 0;

signals:
  void pushView(ActionView *view) const;
  void actionActivated(AbstractAction *action) const;
};

class ListActionView : public ActionView {
  OmniList *_list;
  std::vector<AbstractPannelActionnable *> _actions;

  bool eventFilter(QObject *sender, QEvent *event) override {
    if (sender == this && event->type() == QEvent::KeyPress) {
      auto keyEvent = static_cast<QKeyEvent *>(event);

      switch (keyEvent->key()) {
      case Qt::Key_Up:
        return _list->selectUp();
      case Qt::Key_Down:
        return _list->selectDown();
      case Qt::Key_Return:
        _list->activateCurrentSelection();
        return true;
      }
    }

    return false;
  }

public:
  ListActionView() : _list(new OmniList()) {
    auto layout = new QVBoxLayout;

    layout->addWidget(_list);
    setLayout(layout);

    installEventFilter(this);

    connect(_list, &OmniList::itemActivated, this, &ListActionView::onItemActivated);
  }

  bool handleKey(QKeyEvent *keyEvent) override {
    for (auto action : _actions) {
      if (!action->shortcut) continue;
      if (KeyboardShortcut(*action->shortcut) == keyEvent) {
        if (auto section = dynamic_cast<ActionSection *>(action)) {
          qDebug() << "section";
          // emit pushView(new SectionListView(section));
        }

        if (auto ac = dynamic_cast<AbstractAction *>(action)) { emit actionActivated(ac); }

        return true;
      }
    }

    return false;
  }

  void onItemActivated(const OmniList::AbstractVirtualItem &item) {
    auto &listItem = static_cast<const ActionListItem &>(item);
    auto actionnable = listItem.action;

    if (auto section = dynamic_cast<ActionSection *>(actionnable)) {
      qDebug() << "section";
      // emit pushView(new SectionListView(section));
    }

    if (auto action = dynamic_cast<AbstractAction *>(actionnable)) { emit actionActivated(action); }
  }

  std::vector<AbstractPannelActionnable *> actions() const override { return _actions; }

  void renderActionPannelModel(const std::vector<ActionItem> &actions) {
    std::vector<std::unique_ptr<OmniList::AbstractVirtualItem>> items;

    _actions.clear();

    for (const auto &actionLike : actions) {
      if (auto ptr = std::get_if<AbstractAction *>(&actionLike)) {
        auto action = *ptr;

        _actions.push_back(action);
        items.push_back(std::make_unique<ActionListItem>(action));
      }

      if (auto ptr = std::get_if<ActionSection *>(&actionLike)) {
        auto action = *ptr;

        _actions.push_back(action);
        items.push_back(std::make_unique<ActionListItem>(action));
      }

      else if (auto ptr = std::get_if<ActionLabel>(&actionLike)) {
        items.push_back(std::make_unique<OmniList::VirtualSection>(ptr->label()));
      }
    }

    _list->updateFromList(items, OmniList::SelectionPolicy::SelectFirst);
  }
};

class SectionListView : public ListActionView {
  ActionSection *_section;

  SectionListView(ActionSection *section) : _section(section) {}

  void onSearchChanged(const QString &text) override {
    renderActionPannelModel(_section->generateItems(text));
  }
};

class RootActionView : public ListActionView {
public:
  RootActionView(const std::vector<ActionItem> &actions) { renderActionPannelModel(actions); }
};

struct ActionViewSnapshot {
  QString text;
  ActionView *view;
};

class ActionPopover : public QWidget {
  Q_OBJECT

  QLineEdit *input;
  QStackedLayout *_viewLayout;
  std::stack<ActionViewSnapshot> _viewStack;

  void paintEvent(QPaintEvent *event) override;
  bool eventFilter(QObject *obj, QEvent *event) override;

  void closeEvent(QCloseEvent *event) override {
    QWidget::closeEvent(event);
    emit closed();
  }

  void showEvent(QShowEvent *event) override {
    QWidget::showEvent(event);
    emit opened();
  }

signals:
  void actionExecuted(AbstractAction *action);
  void closed() const;
  void opened() const;

public:
  std::vector<ActionItem> _items;
  std::vector<AbstractAction *> _actionnables;

  bool findBoundAction(QKeyEvent *event) {
    //qDebug() << "find bound action";
    if (_viewStack.empty()) return false;

    return _viewStack.top().view->handleKey(event);
  }

  void showActions();
  void toggleActions();

  AbstractAction *actionnable(int targetIndex = 0) const {
    if (_viewStack.empty()) return nullptr;

    auto actions = _viewStack.top().view->actions();

    // if (actions.size() < targetIndex) return actions.at(targetIndex);

    return nullptr;
  }

  void textChanged(const QString &text) const {
    if (_viewStack.empty()) return;

    _viewStack.top().view->onSearchChanged(text);
  }

  void clear() {
    while (!_viewStack.empty()) {
      popCurrentView();
    }
  }

  void popCurrentView() {
    if (_viewStack.empty()) return;

    auto &snap = _viewStack.top();

    input->setText(snap.text);
    _viewLayout->removeWidget(snap.view);
    snap.view->deleteLater();
    _viewStack.pop();

    if (!_viewStack.empty()) { connectView(_viewStack.top().view); }
  }

  void connectView(ActionView *view) {
    connect(view, &ActionView::actionActivated, this, &ActionPopover::actionExecuted);
  }

  void disconnectView(ActionView *view) {
    disconnect(view, &ActionView::actionActivated, this, &ActionPopover::actionExecuted);
  }

  void pushView(ActionView *view) {
    if (!_viewStack.empty()) { disconnectView(_viewStack.top().view); }

    connectView(view);

    _viewLayout->addWidget(view);
    _viewStack.push({
        .text = input->text(),
        .view = view,
    });
  }

  ActionPopover(QWidget *parent = 0);

public slots:
  void setSignalActions(const QList<AbstractAction *> &actions) {
    setActions({actions.begin(), actions.end()});
  }

  const std::vector<ActionItem> &items() const { return _items; }
  const std::vector<AbstractAction *> &actions() const { return _actionnables; }

  void setActions(const std::vector<ActionItem> &items) {
    clear();
    qDebug() << "cleared";
    pushView(new RootActionView(items));
  }
};
