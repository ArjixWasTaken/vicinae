#include <QUuid>
#include <cerrno>
#include <cinttypes>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <filesystem>
#include <functional>
#include <jsoncpp/json/json.h>
#include <jsoncpp/json/value.h>
#include <qapplication.h>
#include <sys/socket.h>
#include <sys/un.h>

#include "app.hpp"
#include <ctime>
#include <fcntl.h>
#include <iostream>
#include <memory>
#include <sched.h>
#include <string_view>
#include <sys/select.h>
#include <sys/wait.h>
#include <toml++/toml.hpp>
#include <unistd.h>

struct ConfigExtension {
  std::string name;
  bool enabled;
  std::vector<std::string> exec;
};

struct Config {
  std::vector<ConfigExtension> extensions;
};

std::unique_ptr<Config> loadConfig(std::string_view path) {
  Config cfg;
  toml::table tbl = toml::parse_file(path);

  if (toml::array *arr = tbl["extensions"].as_array()) {
    for (const auto &item : *arr) {
      if (const toml::table *ext = item.as_table()) {
        ConfigExtension extension;

        extension.name = ext->get_as<std::string>("name")->value_or("Unknown");
        extension.enabled = ext->get_as<bool>("enabled")->value_or(false);

        if (const toml::array *arr = ext->get("exec")->as_array()) {
          for (const auto &s : *arr) {
            extension.exec.push_back(s.as_string()->value_or(""));
          }
        }

        cfg.extensions.push_back(extension);
      }
    }
  }

  return std::make_unique<Config>(cfg);
}

char **vectorToArgv(const std::vector<std::string> &ss) {
  char **argv = new char *[ss.size() + 1];

  for (size_t i = 0; i != ss.size(); ++i)
    argv[i] = strdup(ss.at(i).c_str());

  argv[ss.size()] = 0;

  return argv;
}

enum ExtensionStatus {
  RUNNING,
  CRASHED,
};

struct Connection {
  time_t createdAt;
  int fd;
};

struct Extension {
  std::string name;
  time_t startedAt;
  struct {
    pid_t pid;
    int in;
    int out;
  } proc;
  std::optional<Connection> connection;
  ExtensionStatus status;
  std::string token;
};

int main(int argc, char **argv) {
  auto cfg = loadConfig("config.toml");
  std::map<std::string, Extension> extensions;
  fd_set readSet = {0}, writeSet = {0};
  int daemonSock = socket(AF_UNIX, SOCK_STREAM, 0);

  fcntl(daemonSock, F_SETFD, fcntl(daemonSock, F_GETFD) | O_NONBLOCK);
  FD_SET(daemonSock, &readSet);

  unlink("daemon.sock");
  struct sockaddr_un saddr = {AF_UNIX, "daemon.sock"};

  if (bind(daemonSock, (const struct sockaddr *)&saddr, sizeof(saddr)) == -1) {
    perror("Failed to bind");
  }

  if (listen(daemonSock, 1024) == -1) {
    perror("Failed to listen");
  }

  for (const auto &ext : cfg->extensions) {

    if (!ext.enabled)
      continue;

    auto &extension = extensions[ext.name] = {};

    extension.name = ext.name;
    extension.startedAt = time(0);
    extension.status = ExtensionStatus::RUNNING;
    extension.token = QUuid::createUuid().toString().toStdString();

    int pipefd[2];

    if (pipe2(pipefd, 0) == -1) {
      perror("Failed to pipe()");
    }

    extension.proc.pid = fork();

    if (extension.proc.pid == 0) {
      close(pipefd[0]);
      auto argv = vectorToArgv(ext.exec);

      setenv("TOKEN", extension.token.c_str(), 1);
      setenv("ENDPOINT",
             (std::filesystem::current_path() / "daemon.sock").c_str(), 1);

      /*
  if (dup2(pipefd[1], STDOUT_FILENO) == -1) {
    perror("Failed to dup2 stdout:");
  }
      */

      if (execvp(argv[0], argv) == -1) {
        perror("Failed to execvp extension:");
      }

      extension.status = ExtensionStatus::CRASHED;
    }

    close(pipefd[1]);
    extension.proc.in = pipefd[0];
    FD_SET(pipefd[0], &readSet);
  }

  QApplication qapp(argc, argv);
  auto app = AppWindow();

  app.show();

  return qapp.exec();

  char buf[8096];
  bool isRunning = true;

  std::vector<Connection> connections;
  std::map<int, Extension *> dataFdToExtension;

  while (isRunning) {
    fd_set readFds = readSet;
    fd_set writeFds = writeSet;

    std::cout << "selecting..." << std::endl;
    if (select(1024, &readFds, nullptr, nullptr, nullptr) != -1) {
      std::cout << "selecting..." << std::endl;
      // accept new connection on socket
      if (FD_ISSET(daemonSock, &readFds)) {
        int client = accept(daemonSock, nullptr, nullptr);

        if (client <= 0) {
          std::cout << "Failed to accept" << std::endl;
          continue;
        }

        std::cout << "new connection" << std::endl;

        connections.push_back({.createdAt = time(0), .fd = client});
        FD_SET(client, &readSet);
      }

      for (const auto &conn : connections) {
        if (FD_ISSET(conn.fd, &readFds)) {
          //std::cout << conn.fd << " wants to read" << std::endl;
          uint32_t mlen = 0;
          int rc = read(conn.fd, &mlen, sizeof(mlen));

          if (rc < sizeof(mlen)) {
            //std::cout << "Failed to read message length!" << std::endl;
            continue;
          }

          std::cout << "message of length=" << mlen << std::endl;

          rc = read(conn.fd, buf, mlen);

          if (rc < mlen) {
            std::cout << "Failed to read message of mlen length!" << std::endl;
            continue;
          }

          buf[rc] = 0;

          Json::Reader reader;
          Json::Value value;

          reader.parse(buf, value);

          std::string type = value["type"].asString();
          Json::Value data = value["data"];

          if (type == "echo") {
            if (auto it = dataFdToExtension.find(conn.fd);
                it != dataFdToExtension.end()) {
              std::cout << "extension " << it->first << " says: " << "\""
                        << data["message"] << "\"" << std::endl;
            }
          }

          if (type == "render") {
            if (auto it = dataFdToExtension.find(conn.fd);
                it != dataFdToExtension.end()) {
              std::cout << "extension " << it->first << data["root"]
                        << std::endl;
            }
          }

          if (type == "register") {
            std::string token = data["token"].asString();

            for (auto &[k, v] : extensions) {
              if (v.token == token) {
                v.connection = conn;
                dataFdToExtension[conn.fd] = &v;
              }
            }

            std::cout << "token: " << token << std::endl;
          }
        }
      }

      /*
  for (auto &[k, v] : extensions) {
    if (v.status != ExtensionStatus::RUNNING)
      continue;

    if (FD_ISSET(v.proc.in, &readFds)) {
      int rc;

      rc = read(v.proc.in, buf, sizeof(buf));

      if (rc <= 0) {
        if (waitpid(v.proc.pid, 0, WNOHANG) == v.proc.pid) {
          std::cout << "Child process for " << k << " has exited"
                    << std::endl;
          v.status = ExtensionStatus::CRASHED;
          FD_CLR(v.proc.in, &readSet);
        }
        isRunning = false;
        break;
      }

      buf[rc] = 0;
      std::cout << "[" << k << "] " << buf;
    }
  }
      */
    }
  }

  return 0;
}
