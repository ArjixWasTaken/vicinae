"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bus = exports.createHandler = void 0;
const crypto_1 = require("crypto");
const worker_threads_1 = require("worker_threads");
;
class Bus {
    port;
    requestMap = new Map();
    eventListeners = new Map();
    handleMessage(message) {
        const { envelope, data } = message;
        console.log('request map size is ', this.requestMap.size);
        console.log('got message', { envelope });
        if (envelope.type == 'response') {
            const request = this.requestMap.get(envelope.id);
            if (!request) {
                console.error(`Received response for unknown request ${envelope.action} ${envelope.id}`);
                return;
            }
            this.requestMap.delete(envelope.id);
            request.resolve(message);
            console.log({ resolve: message });
            return;
        }
        if (envelope.type == 'event') {
            let start = performance.now();
            console.log(`[LISTENER] iterating on ${this.eventListeners.size} listeners`);
            const listeners = this.listEventListeners(envelope.action);
            let end = performance.now();
            console.log(`[LISTENER] got ${listeners.length} listeners in ${end - start}ms`);
            start = performance.now();
            for (const listener of listeners) {
                listener.callback(...(data.args ?? []));
            }
            end = performance.now();
            console.log(`[LISTENER] Invoked listeners in ${end - start}ms`);
            return;
        }
        if (envelope.type == 'request') {
            console.error(`Direct requests to extensions are not yet supported`);
            return;
        }
        console.log('resolved request', message);
    }
    constructor(port) {
        this.port = port;
        if (!port)
            return;
        console.error('INSTANCIATE BUS');
        port.on('message', this.handleMessage.bind(this));
        port.on('messageerror', (error) => {
            console.error(`Message error from manager`, error);
        });
        port.on('close', () => {
            console.error(`Parent port closed prematurely`);
        });
    }
    listEventListeners(type) {
        return this.eventListeners.get(type) ?? [];
    }
    subscribe(type, cb) {
        const item = { id: (0, crypto_1.randomUUID)(), callback: cb };
        let listeners = this.eventListeners.get(type);
        if (!listeners) {
            this.eventListeners.set(type, [item]);
        }
        else {
            listeners.push(item);
        }
        return {
            unsubscribe: () => {
                const listeners = this.eventListeners.get(type) ?? [];
                const index = listeners.indexOf(item);
                if (index != -1) {
                    listeners.splice(index, 1);
                    if (listeners.length === 0) {
                        this.eventListeners.delete(type);
                    }
                }
            }
        };
    }
    emit(action, data) {
        const id = (0, crypto_1.randomUUID)();
        const message = {
            envelope: {
                type: 'event',
                action,
                id
            },
            data,
            error: null,
        };
        this.port.postMessage(message);
    }
    request(action, data = {}, options = {}) {
        const id = (0, crypto_1.randomUUID)();
        const { rejectOnError = true } = options;
        return new Promise((resolve, reject) => {
            let timeout;
            if (options.timeout) {
                timeout = setTimeout(() => reject(new Error(`request timed out`)), options.timeout);
            }
            const resolver = (message) => {
                clearTimeout(timeout);
                if (message.error && rejectOnError) {
                    return reject(message.error.message ?? "Unknown error");
                }
                resolve(message);
            };
            try {
                this.requestMap.set(id, { resolve: resolver });
                console.log(`add id for message type ${action}` + id);
                const message = {
                    envelope: {
                        type: 'request',
                        action,
                        id
                    },
                    data,
                    error: null
                };
                this.port.postMessage(message);
            }
            catch (error) {
                reject(error);
            }
        });
    }
}
;
const createHandler = (handler) => {
    const id = (0, crypto_1.randomUUID)();
    exports.bus.subscribe(id, handler);
    return id;
};
exports.createHandler = createHandler;
exports.bus = new Bus(worker_threads_1.parentPort);
